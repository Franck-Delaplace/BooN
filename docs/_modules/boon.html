<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boon &mdash; BooN 1.05 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=8214e1ae"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            BooN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">BooN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">boon</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boon</h1><div class="highlight"><pre>
<span></span><span class="c1"># Boolean Network analysis module</span>
<span class="c1"># Author: Franck Delaplace</span>
<span class="c1"># Creation date: January 2024</span>

<span class="c1"># In comments :</span>
<span class="c1"># DEF means definition which is a code part gathering functions related to a process or an object definition,</span>
<span class="c1"># STEP means main steps</span>
<span class="c1"># WARNING is a warning.</span>
<span class="c1"># These terms can be used to color comments in PyCharm or else.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">z3</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">pulp</span> <span class="kn">import</span> <span class="n">PULP_CBC_CMD</span>

<span class="kn">import</span> <span class="nn">netgraph</span> <span class="k">as</span> <span class="nn">ng</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">to_rgb</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Implies</span><span class="p">,</span> <span class="n">Equivalent</span>
<span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_cnf</span><span class="p">,</span> <span class="n">to_dnf</span><span class="p">,</span> <span class="n">is_dnf</span>
<span class="kn">from</span> <span class="nn">sympy.parsing.sympy_parser</span> <span class="kn">import</span> <span class="n">parse_expr</span>
<span class="kn">from</span> <span class="nn">boon.logic</span> <span class="kn">import</span> <span class="n">LOGICAL</span><span class="p">,</span> <span class="n">SYMPY</span><span class="p">,</span> <span class="n">BOOLNET</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">,</span> <span class="n">firstsymbol</span>
<span class="kn">import</span> <span class="nn">boon.logic</span> <span class="k">as</span> <span class="nn">logic</span>

<span class="kn">import</span> <span class="nn">libsbml</span>

<span class="c1"># CONSTANTS</span>
<span class="n">SIGNCOLOR</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;crimson&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;steelblue&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;forestgreen&#39;</span><span class="p">}</span>  <span class="c1"># colors of edges in the interaction graph w.r.t. to signs.</span>
<span class="n">COLORSIGN</span> <span class="o">=</span> <span class="p">{</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">color</span><span class="p">):</span> <span class="n">sign</span> <span class="k">for</span> <span class="n">sign</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">SIGNCOLOR</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="n">EXTBOON</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.boon&quot;</span>  <span class="c1"># file extension for save and load.</span>
<span class="n">EXTXT</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.txt&quot;</span>     <span class="c1"># file extension for to_textfile and from_textfile.</span>
<span class="n">EXTSBML</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.sbml&quot;</span>  <span class="c1"># file extension of SBML file for from_sbmlfile .</span>
<span class="n">CONTROL</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_u&quot;</span>     <span class="c1"># prefix name of the controllers.</span>
<span class="n">BOONSEP</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>     <span class="c1"># separator between the equations of a BooN.</span>
<span class="c1"># color list for graph drawing</span>
<span class="n">COLOR</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gold&#39;</span><span class="p">,</span> <span class="s1">&#39;tomato&#39;</span><span class="p">,</span> <span class="s1">&#39;yellowgreen&#39;</span><span class="p">,</span> <span class="s1">&#39;plum&#39;</span><span class="p">,</span> <span class="s1">&#39;mediumaquamarine&#39;</span><span class="p">,</span> <span class="s1">&#39;darkorange&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;darkkhaki&#39;</span><span class="p">,</span> <span class="s1">&#39;forestgreen&#39;</span><span class="p">,</span> <span class="s1">&#39;salmon&#39;</span><span class="p">,</span> <span class="s1">&#39;lightcoral&#39;</span><span class="p">,</span> <span class="s1">&#39;cornflowerblue&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;paleviolet&#39;</span><span class="p">,</span> <span class="s1">&#39;coral&#39;</span><span class="p">,</span> <span class="s1">&#39;dodgerblue&#39;</span><span class="p">,</span> <span class="s1">&#39;yellowgreen&#39;</span><span class="p">,</span> <span class="s1">&#39;orangered&#39;</span><span class="p">,</span> <span class="s1">&#39;pink&#39;</span><span class="p">,</span> <span class="s1">&#39;blueviolet&#39;</span><span class="p">,</span> <span class="s1">&#39;crimson&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="is_controlled">
<a class="viewcode-back" href="../index.html#boon.is_controlled">[docs]</a>
<span class="k">def</span> <span class="nf">is_controlled</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check whether a formula is controlled.</span>

<span class="sd">    :param formula: the input formula.</span>
<span class="sd">    :type formula: sympy formula.</span>
<span class="sd">    :return: True if the formula is controlled otherwise False</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">var</span><span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">CONTROL</span><span class="p">),</span> <span class="n">formula</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># Boolean True, False not controlled.</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="core2actions">
<a class="viewcode-back" href="../index.html#boon.core2actions">[docs]</a>
<span class="k">def</span> <span class="nf">core2actions</span><span class="p">(</span><span class="n">core</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert the core to a list of actions where an action is a list of (variable, Boolean).</span>
<span class="sd">    The actions are sorted by length meaning that the more parsimonious actions are at first.</span>

<span class="sd">    :param core: the core.</span>
<span class="sd">    :type core: frozenset of literals.</span>
<span class="sd">    :return: A list of combined actions where an action is defined as:[(variable,bool) ...]</span>
<span class="sd">    :rtype: list[list[tuple]]&quot;&quot;&quot;</span>

    <span class="n">ACTION</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="n">lctrl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">CONTROL</span><span class="p">)</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">symbols</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ctrl</span><span class="p">)[</span><span class="n">lctrl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]),</span> <span class="n">ACTION</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ctrl</span><span class="p">)[</span><span class="n">lctrl</span><span class="p">]])</span> <span class="k">for</span> <span class="n">ctrl</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">]</span> <span class="k">for</span> <span class="n">primes</span> <span class="ow">in</span> <span class="n">core</span><span class="p">]</span>
    <span class="c1"># Sort the actions by length.</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">actions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">actions</span></div>



<div class="viewcode-block" id="asynchronous">
<a class="viewcode-back" href="../index.html#boon.asynchronous">[docs]</a>
<span class="k">def</span> <span class="nf">asynchronous</span><span class="p">(</span><span class="n">variables</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Asynchronous or sequential mode. One variable is updated per transition.</span>

<span class="sd">    :param variables: list of variables.</span>
<span class="sd">    :type variables: list or set</span>
<span class="sd">    :return: set of sets: {{x1},...,{xi},...,{xn}} representing the asynchronous mode.</span>
<span class="sd">    :rtype: frozenset[frozenset[Symbol]]&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">frozenset</span><span class="p">({</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">})</span></div>



<div class="viewcode-block" id="synchronous">
<a class="viewcode-back" href="../index.html#boon.synchronous">[docs]</a>
<span class="k">def</span> <span class="nf">synchronous</span><span class="p">(</span><span class="n">variables</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;synchronous or parallel mode. All the variables are updated jointly per transition.</span>

<span class="sd">        :param variables: list of variables.</span>
<span class="sd">        :type variables: list or set</span>
<span class="sd">        :return: set of sets: {{x1,...,xi,...,xn}} representing the synchronous mode.</span>
<span class="sd">        :rtype: frozenset[frozenset[Symbol]]&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">frozenset</span><span class="p">({</span><span class="nb">frozenset</span><span class="p">({</span><span class="o">*</span><span class="n">variables</span><span class="p">})})</span></div>



<div class="viewcode-block" id="state2int">
<a class="viewcode-back" href="../index.html#boon.state2int">[docs]</a>
<span class="k">def</span> <span class="nf">state2int</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="nb">set</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a set of states to an integer the binary profile of which corresponds to the state of the variables.</span>

<span class="sd">    :param state: state of the variables.</span>
<span class="sd">    :param variables: list of variables. If the list is empty then the encoding order corresponds to the variable occur. (Defaults [])</span>
<span class="sd">    :type state: dict or tuple</span>
<span class="sd">    :type variables: list or set</span>
<span class="sd">    :return: an integer such that its binary profile represents the state.</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BOOL2BIN</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">variables</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="n">bin_profile</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">BOOL2BIN</span><span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">order</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">bin_profile</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">BOOL2BIN</span><span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">order</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">bin_profile</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">BOOL2BIN</span><span class="p">[</span><span class="n">elt</span><span class="p">]</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">state</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bin_profile</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_profile</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="int2state">
<a class="viewcode-back" href="../index.html#boon.int2state">[docs]</a>
<span class="k">def</span> <span class="nf">int2state</span><span class="p">(</span><span class="n">int_state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Convert an integer state to a dictionary state.</span>

<span class="sd">    :param int_state: the state coded into integer.</span>
<span class="sd">    :param variables: list of variables.</span>
<span class="sd">    :type int_state: int</span>
<span class="sd">    :type variables: list or set</span>
<span class="sd">    :return: a dictionary representing the state {variable: boolean stateâ€¦}. .</span>
<span class="sd">    :rtype: dict&quot;&quot;&quot;</span>
    <span class="n">BIN2BOOL</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="n">bin_state</span> <span class="o">=</span> <span class="nb">format</span><span class="p">(</span><span class="n">int_state</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="p">[</span><span class="n">BIN2BOOL</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">bin_state</span><span class="p">]))</span></div>



<div class="viewcode-block" id="hypercube_layout">
<a class="viewcode-back" href="../index.html#boon.hypercube_layout">[docs]</a>
<span class="k">def</span> <span class="nf">hypercube_layout</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">nx</span><span class="o">.</span><span class="n">Digraph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the hypercube layout of a graph.</span>

<span class="sd">    :param arg: the dimension of the hypercube or the network to which the layout is applied.</span>
<span class="sd">    :type arg: int or networkx Digraph</span>
<span class="sd">    :return: a dictionary {int:position} where int is the integer code of the hypercube labels.</span>
<span class="sd">    :rtype: dict&quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()))</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">hypercube_graph</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">state2int</span><span class="p">(</span><span class="n">node</span><span class="p">):</span> <span class="n">pos</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">}</span></div>



<span class="c1"># noinspection PyMethodFirstArgAssignment</span>
<div class="viewcode-block" id="BooN">
<a class="viewcode-back" href="../index.html#boon.BooN">[docs]</a>
<span class="k">class</span> <span class="nc">BooN</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Boolean Network Class.</span>

<span class="sd">    :param  desc:  Boolean network descriptor { variable: formula, ...}.</span>
<span class="sd">    :param  style: output form of the BooN: LOGICAL, SYMPY, MATHEMATICA, JAVA, BOOLNET, ...,</span>
<span class="sd">    :param  pos: the positions of the nodes in the interaction graph. {node:position, ...}.</span>
<span class="sd">    :type  desc: dict</span>
<span class="sd">    :type  style: dict</span>
<span class="sd">    :type  pos: dict&quot;&quot;&quot;</span>
    <span class="n">desc</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">style</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pos</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">LOGICAL</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the BooN object.</span>

<span class="sd">        :param  descriptor: the descriptor of a Boolean Network.</span>
<span class="sd">        :param  style: the output style of formulas  (Default: LOGICAL).</span>
<span class="sd">        :param  pos: positions of the variable in the interaction graph drawing.</span>
<span class="sd">                If empty, the pos are generated during the drawing (Default: {}). &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">descriptor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">descriptor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">style</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BooN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BooN</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">memo</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">BOONSEP</span><span class="p">,</span> <span class="n">assign</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">assign</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">logic</span><span class="o">.</span><span class="n">prettyform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>

<div class="viewcode-block" id="BooN.str">
<a class="viewcode-back" href="../index.html#boon.BooN.str">[docs]</a>
    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">BOONSEP</span><span class="p">,</span> <span class="n">assign</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;=&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representing the BooN. The output format can be parameterized (see style argument of BooN)</span>
<span class="sd">        :param sep: the separator between formulas (default BOONSEP constant)</span>
<span class="sd">        :param assign: the operator defining the assignment of a formula to a variable (e.g. a = f(...)  -&gt; assign is &#39;=&#39;). (Default: &#39;=&#39;)</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :type assign: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">BooN</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The equality between BooNs is based on the descriptor only, and not on the style or the nodes position.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BooN</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">desc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the set of variables.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="BooN.delete">
<a class="viewcode-back" href="../index.html#boon.BooN.delete">[docs]</a>
    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete a variable in a BooN. The formulas must all be in DNF to properly delete the variable.</span>

<span class="sd">        :param  variable: the variable to delete.</span>
<span class="sd">        :type variable: Symbol&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>  <span class="c1"># sub function deleting a variable in a formula.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">formula</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">formula</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">formula</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">formula</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">variable</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">formula</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">And</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">delete</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">formula</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">Or</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Or</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">delete</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">formula</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;a piece of the formula is not recognized&quot;</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;__failed__&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;the variable to delete does not exist&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

        <span class="c1"># Convert BooN in DNF if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">is_dnf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dnf</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooN.rename">
<a class="viewcode-back" href="../index.html#boon.BooN.rename">[docs]</a>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rename a variable.</span>

<span class="sd">        :param  source:  the variable to rename.</span>
<span class="sd">        :param  target:  the variable renaming the source.</span>
<span class="sd">        :type source: Symbol</span>
<span class="sd">        :type target: Symbol&quot;&quot;&quot;</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>

        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;the variable to rename does not exist&quot;</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;the renamed variable cannot be in BooN variables&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">source</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooN.copy">
<a class="viewcode-back" href="../index.html#boon.BooN.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BooN</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a deep copy of the Boolean network.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="c1"># DEF: FILE</span>
<div class="viewcode-block" id="BooN.save">
<a class="viewcode-back" href="../index.html#boon.BooN.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;BooN&quot;</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%b-%y-%H&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">EXTBOON</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the Boolean Network to file.  If the extension is missing then .boon is added.</span>

<span class="sd">        :param filename:  the name of the file to save the network (Default: BooN+date+hour.boon)</span>
<span class="sd">        :type  filename: str&quot;&quot;&quot;</span>

        <span class="n">fullfilename</span> <span class="o">=</span> <span class="n">filename</span> <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="k">else</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">EXTBOON</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullfilename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="BooN.load">
<a class="viewcode-back" href="../index.html#boon.BooN.load">[docs]</a>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the Boolean Network from file. If the extension is missing then .boon is added.</span>

<span class="sd">        :param filename: the name of the file to load the network.</span>
<span class="sd">        :type  filename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fullfilename</span> <span class="o">=</span> <span class="n">filename</span> <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="k">else</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">EXTBOON</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullfilename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">boon</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">boon</span><span class="o">.</span><span class="n">desc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">boon</span><span class="o">.</span><span class="n">style</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">boon</span><span class="o">.</span><span class="n">pos</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;No such file or directory, no changes&quot;</span><span class="p">,</span> <span class="n">fullfilename</span><span class="p">,</span> <span class="s2">&quot;WARNING&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooN.to_textfile">
<a class="viewcode-back" href="../index.html#boon.BooN.to_textfile">[docs]</a>
    <span class="k">def</span> <span class="nf">to_textfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">BOONSEP</span><span class="p">,</span> <span class="n">assign</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">BOOLNET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Export the Boolean network in a text file. If the file extension is missing then .txt is added. The default format is BOOLNET.</span>

<span class="sd">        :param filename: the file name to export the Boolean network. If the file extension is missing then .txt is added.</span>
<span class="sd">        :param sep: the separator between formulas (default BOONSEP constant)</span>
<span class="sd">        :param assign: the operator defining the formula for a variable, e.g. a = f(...)  -&gt; assign is &#39;=&#39;  (Default: &#39;,&#39;).</span>
<span class="sd">        :param ops: a dictionary stipulating how the operators And, Or, Not  are syntactically written  (Default: BOOLNET).</span>
<span class="sd">        :type  filename: str</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :type assign: str</span>
<span class="sd">        :type ops: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fullfilename</span> <span class="o">=</span> <span class="n">filename</span> <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="k">else</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">EXTXT</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullfilename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">style</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">ops</span>  <span class="c1"># assign ops to style</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span>  <span class="c1"># convert to string with regard to sep and assign</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="BooN.from_textfile">
<a class="viewcode-back" href="../index.html#boon.BooN.from_textfile">[docs]</a>
    <span class="k">def</span> <span class="nf">from_textfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">BOONSEP</span><span class="p">,</span> <span class="n">assign</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">BOOLNET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import the Boolean network from a text file. The syntax depend on the ops&#39; descriptor.</span>
<span class="sd">        The formulas must be in normal form containing OR, AND, NOT operators only.</span>
<span class="sd">        The nodes are circularly mapped.</span>

<span class="sd">        :param filename: the file name to import the Boolean network. If the file extension is missing then .txt is added.</span>
<span class="sd">        :param sep: the separator between definitions  (default BOONSEP constant)</span>
<span class="sd">        :param assign: the operator defining the formula for a variable, e.g. a = f(...)  -&gt; assign is &#39;=&#39;  (Default: &#39;,&#39;).</span>
<span class="sd">        :param ops: a dictionary stipulating how the operators And, Or, Not  are syntactically written  (Default: BOOLNET).</span>
<span class="sd">        :type  filename: str</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :type assign: str</span>
<span class="sd">        :type ops: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fullfilename</span> <span class="o">=</span> <span class="n">filename</span> <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="k">else</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">EXTXT</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fullfilename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>  <span class="c1"># Join all the lines in 1 string.</span>
                <span class="n">text</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span>  <span class="c1"># And next separate the string w.r.t. the separator BOONSEP</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Parse the network description. A line is of the form: &lt;var&gt; = &lt;formula&gt;, comment line start with &#39;#&#39;</span>
                    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>  <span class="c1"># Skip comment.</span>
                        <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>  <span class="c1"># Skip empty line.</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>  <span class="c1"># Find &#39;=&#39; operator.</span>
                            <span class="n">equal</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">assign</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">errmsg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error, the assignment (sign:</span><span class="si">{</span><span class="n">assign</span><span class="si">}</span><span class="s2">) is missing, line </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> in file&quot;</span><span class="p">,</span> <span class="n">fullfilename</span><span class="p">,</span> <span class="s2">&quot;READ ERROR&quot;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">try</span><span class="p">:</span>  <span class="c1"># Set the variable to Symbol.</span>
                            <span class="n">var</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="n">line</span><span class="p">[:</span><span class="n">equal</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">errmsg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error, wrong variable name, line </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> in file&quot;</span><span class="p">,</span> <span class="n">fullfilename</span><span class="p">,</span> <span class="s2">&quot;READ ERROR&quot;</span><span class="p">)</span>
                            <span class="k">return</span>

                        <span class="k">try</span><span class="p">:</span>  <span class="c1"># Parse formula.</span>
                            <span class="c1"># STEP:  rewrite the operators to Python/Sympy operators</span>
                            <span class="n">formula</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">equal</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                            <span class="n">formula</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">And</span><span class="p">],</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>  <span class="c1"># Convert And</span>
                            <span class="n">formula</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">Or</span><span class="p">],</span> <span class="s1">&#39;|&#39;</span><span class="p">)</span>  <span class="c1"># Convert Or</span>
                            <span class="n">formula</span> <span class="o">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">Not</span><span class="p">],</span> <span class="s1">&#39;~&#39;</span><span class="p">)</span>  <span class="c1"># Convert Not</span>

                            <span class="c1"># for constant True, False the code can be also a part of the variable name (e.g. True = 0, False = 1 and X101 as variable)</span>
                            <span class="c1"># Therefore the replacement occurs iff it is located after a space, a logical operator or at the start of the formula.</span>
                            <span class="n">formula</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;((?&lt;=\||&amp;|~|\s|\()|^)&#39;</span> <span class="o">+</span> <span class="n">ops</span><span class="p">[</span><span class="kc">False</span><span class="p">],</span> <span class="s1">&#39;False&#39;</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>  <span class="c1"># Convert False</span>
                            <span class="n">formula</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;((?&lt;=\||&amp;|~|\s|\()|^)&#39;</span> <span class="o">+</span> <span class="n">ops</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>  <span class="c1"># Convert True</span>

                            <span class="c1"># STEP: Now the formula is rewritten in Python/Sympy syntax then parse it.</span>
                            <span class="n">trueformula</span> <span class="o">=</span> <span class="n">parse_expr</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
                            <span class="n">errmsg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error, wrong formula parsing, line </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> in file&quot;</span><span class="p">,</span> <span class="n">fullfilename</span><span class="p">,</span> <span class="s2">&quot;READ ERROR&quot;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="n">desc</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">var</span><span class="p">:</span> <span class="n">trueformula</span><span class="p">})</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;No such file or directory, no changes&quot;</span><span class="p">,</span> <span class="n">fullfilename</span><span class="p">,</span> <span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="n">ig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_graph</span>
        <span class="n">circular_positions</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">get_circular_layout</span><span class="p">([(</span><span class="nb">str</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">tgt</span><span class="p">))</span> <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">ig</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
                                                    <span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">)</span>
                                                    <span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
                                                    <span class="p">,</span> <span class="n">reduce_edge_crossings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">symbols</span><span class="p">(</span><span class="n">var</span><span class="p">):</span> <span class="n">pos</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">circular_positions</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="BooN.from_sbmlfile">
<a class="viewcode-back" href="../index.html#boon.BooN.from_sbmlfile">[docs]</a>
    <span class="k">def</span> <span class="nf">from_sbmlfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import the Boolean network from a sbml file.</span>

<span class="sd">        :param filename: the file name to import the Boolean network. If the extension is missing then .sbml is added.</span>
<span class="sd">        :type  filename: str&quot;&quot;&quot;</span>

        <span class="n">sbml_file</span> <span class="o">=</span> <span class="n">filename</span> <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="k">else</span> <span class="n">filename</span> <span class="o">+</span> <span class="n">EXTSBML</span>

        <span class="c1"># STEP: Open the SBML file and get the qualitative_model model</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">libsbml</span><span class="o">.</span><span class="n">SBMLReader</span><span class="p">()</span>
        <span class="n">document</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">readSBML</span><span class="p">(</span><span class="n">sbml_file</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">document</span><span class="o">.</span><span class="n">getNumErrors</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Check if there is no errors while reading the SBML files.</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;Error reading SBML file&quot;</span><span class="p">,</span> <span class="n">document</span><span class="o">.</span><span class="n">getErrorLog</span><span class="p">()</span><span class="o">.</span><span class="n">toString</span><span class="p">(),</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">getModel</span><span class="p">()</span>  <span class="c1"># Check whether a model exists.</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;No model present in SBML file.&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">qualitative_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getPlugin</span><span class="p">(</span><span class="s2">&quot;qual&quot;</span><span class="p">)</span>  <span class="c1"># Get the qualitative_model part of the model.</span>
        <span class="k">if</span> <span class="n">qualitative_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Check whether a Qual model exists.</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;The model does not have the Qual plugin&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Create a dictionary associating the string name of a variable to its corresponding Symbol.</span>
        <span class="n">vars_dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">qualitative_model</span><span class="o">.</span><span class="n">getListOfQualitativeSpecies</span><span class="p">():</span>
            <span class="n">species_name</span> <span class="o">=</span> <span class="n">species</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span> <span class="k">if</span> <span class="n">species</span><span class="o">.</span><span class="n">isSetName</span><span class="p">()</span> <span class="k">else</span> <span class="n">species</span><span class="o">.</span><span class="n">getId</span><span class="p">()</span>
            <span class="n">vars_dic</span><span class="p">[</span><span class="n">species_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="n">species_name</span><span class="p">)</span>

        <span class="c1"># STEP: read the formulas from transitions and convert them to sympy format.</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">qualitative_model</span><span class="o">.</span><span class="n">getListOfTransitions</span><span class="p">():</span>  <span class="c1"># Scan all the transitions.</span>
            <span class="c1"># Get the output variable</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">transition</span><span class="o">.</span><span class="n">getListOfOutputs</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># check whether there is a single output</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;Multiple variables assigned. List of variables&quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getQualitativeSpecies</span><span class="p">())</span>

            <span class="c1"># Get the formula</span>
            <span class="n">logic_terms</span> <span class="o">=</span> <span class="n">transition</span><span class="o">.</span><span class="n">getListOfFunctionTerms</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">logic_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Empty transition in SBML file, skip it.</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">logic_terms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># check whether there exists a single formula only, error otherwise</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;Multiple logic terms present. Number of terms&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">logic_terms</span><span class="p">),</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Get the SBML QUAL formula</span>
                <span class="n">formula</span> <span class="o">=</span> <span class="n">libsbml</span><span class="o">.</span><span class="n">formulaToL3String</span><span class="p">(</span><span class="n">logic_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getMath</span><span class="p">())</span>

            <span class="c1"># Convert the SBML QUAL formula into sympy syntax before parsing it.</span>
            <span class="n">normal_formula</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\|\|&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>  <span class="c1"># convert || to |</span>
            <span class="n">normal_formula</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&amp;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="n">normal_formula</span><span class="p">)</span>  <span class="c1"># convert &amp;&amp; to &amp;</span>
            <span class="n">normal_formula</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(\w+)\s*==\s*1\b&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">normal_formula</span><span class="p">)</span>  <span class="c1"># convert &lt;var&gt; == 1 to &lt;var&gt;</span>
            <span class="n">normal_formula</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b(\w+)\s*==\s*0\b&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;~\1&#39;</span><span class="p">,</span> <span class="n">normal_formula</span><span class="p">)</span>  <span class="c1"># convert &lt;var&gt; == 0 to ~ &lt;var&gt;</span>
            <span class="c1"># Parse the formula to obtain a sympy formula and complete desc</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sympy_formula</span> <span class="o">=</span> <span class="n">parse_expr</span><span class="p">(</span><span class="n">normal_formula</span><span class="p">,</span> <span class="n">vars_dic</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;Syntax error in the following formula&quot;</span><span class="p">,</span> <span class="n">normal_formula</span><span class="p">,</span> <span class="s2">&quot;SYNTAX ERROR&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">desc</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy_formula</span>

        <span class="c1"># STEP: define the BooN with a circular layout for nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="n">ig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_graph</span>
        <span class="n">circular_positions</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">get_circular_layout</span><span class="p">([(</span><span class="nb">str</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">tgt</span><span class="p">))</span> <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">ig</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
                                                    <span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">)</span>
                                                    <span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
                                                    <span class="p">,</span> <span class="n">reduce_edge_crossings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">symbols</span><span class="p">(</span><span class="n">var</span><span class="p">):</span> <span class="n">pos</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">circular_positions</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


    <span class="c1"># DEF: NORMAL FORM CONVERSION</span>
<div class="viewcode-block" id="BooN.cnf">
<a class="viewcode-back" href="../index.html#boon.BooN.cnf">[docs]</a>
    <span class="k">def</span> <span class="nf">cnf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">Symbol</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">simplify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the formulas of the Boolean network to CNF.</span>

<span class="sd">        :param  variable: the variable where the formula  is to be converted in CNF (Default None). If variable is None then all the formulas are converted to CNF.</span>
<span class="sd">        :param  simplify: Boolean flag determining whether the formula should be simplified (Default True).</span>
<span class="sd">        :param  force: Boolean flag forcing the complete simplification of the resulting CNF (Default True).</span>
<span class="sd">        :type  variable: Symbol</span>
<span class="sd">        :type  simplify: bool</span>
<span class="sd">        :type  force: bool&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_cnf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;The variable is not found&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_cnf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooN.dnf">
<a class="viewcode-back" href="../index.html#boon.BooN.dnf">[docs]</a>
    <span class="k">def</span> <span class="nf">dnf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">Symbol</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">simplify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert formula(s) of the Boolean network to DNF.</span>

<span class="sd">        :param  variable: the variable where the formula is to be converted in DNF (Default: None). If variable is None then all the formulas are converted to DNF.</span>
<span class="sd">        :param  simplify: Boolean flag determining whether the formula should be simplified (Default: True).</span>
<span class="sd">        :param  force: Boolean flag forcing the complete simplification (Default: True).</span>
<span class="sd">        :type  variable: Symbol</span>
<span class="sd">        :type  simplify: bool</span>
<span class="sd">        :type  force: bool&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_dnf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;The variable is not found&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_dnf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span></div>


    <span class="c1"># DEF: INTERACTION GRAPH</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interaction_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the interaction graph.</span>

<span class="sd">        :return: the interaction graph.</span>
<span class="sd">        :rtype: networkx DiGraph&quot;&quot;&quot;</span>
        <span class="n">all_dnf</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">is_dnf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>  <span class="c1"># Check whether all the formulas are in DNF.</span>
        <span class="k">if</span> <span class="n">all_dnf</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if some formulas are not in DNF then convert them into DNF.</span>
            <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">net</span><span class="o">.</span><span class="n">dnf</span><span class="p">()</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">variables</span>
        <span class="n">ig</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">clauses</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">Or</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],)</span>

            <span class="c1"># get literals_formula clause of the dnf associated to the variable.</span>
            <span class="n">literals_formula</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># set of all literals in the dnf</span>
            <span class="n">all_literals_clauses</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of literals per clauses</span>
            <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">:</span>
                <span class="n">literals_clause</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">clause2literals</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>
                <span class="n">literals_formula</span> <span class="o">=</span> <span class="n">literals_formula</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">literals_clause</span><span class="p">)</span>
                <span class="n">all_literals_clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">literals_clause</span><span class="p">)</span>

            <span class="c1"># Find positive variables.</span>
            <span class="n">posvariables</span> <span class="o">=</span> <span class="p">{</span><span class="n">lit</span> <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">literals_formula</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)}</span>
            <span class="c1"># Find negative variables.</span>
            <span class="n">negvariables</span> <span class="o">=</span> <span class="p">{</span><span class="n">firstsymbol</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">literals_formula</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">Not</span><span class="p">)}</span>
            <span class="c1"># critical variables occur positively and negatively in the formula.</span>
            <span class="n">critical_variables</span> <span class="o">=</span> <span class="n">posvariables</span> <span class="o">&amp;</span> <span class="n">negvariables</span>
            <span class="c1"># remove critical variables from positive and negative variables to get pure sets.</span>
            <span class="n">negvariables</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">critical_variables</span><span class="p">)</span>
            <span class="n">posvariables</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">critical_variables</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">posvariables</span><span class="p">:</span>  <span class="c1"># Define interaction for pure positive variables.</span>
                <span class="n">module</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lits</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_literals_clauses</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">lits</span><span class="p">:</span>
                        <span class="n">module</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">ig</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">negvariables</span><span class="p">:</span>  <span class="c1"># Define interaction for pure negative variables.</span>
                <span class="n">module</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lits</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_literals_clauses</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">Not</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lits</span><span class="p">:</span>
                        <span class="n">module</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
                <span class="n">ig</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">sign</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">critical_variables</span><span class="p">:</span>  <span class="c1"># Define interaction for positive and negative variables.</span>
                <span class="n">module</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lits</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_literals_clauses</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># find the appropriate modules w.r.t. to literals</span>
                    <span class="k">if</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">lits</span><span class="p">:</span>
                        <span class="n">module</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">Not</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lits</span><span class="p">:</span>
                        <span class="n">module</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="n">ig</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">)</span>

        <span class="n">ig</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ig</span>

<div class="viewcode-block" id="BooN.draw_IG">
<a class="viewcode-back" href="../index.html#boon.BooN.draw_IG">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_IG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IG</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">modular</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw the interaction graph.</span>

<span class="sd">        :param  IG: the interaction graph or None. If None, the interaction graph is generated from BooN (Default: None).</span>
<span class="sd">        :param  modular: Boolean indicating whether the modular structure of interactions is displayed if True (Default: False)</span>
<span class="sd">        :param  kwargs: additional keyword arguments to pass to the interaction graph drawing</span>
<span class="sd">        :type   IG: networkx DiGraph</span>
<span class="sd">        :type   modular: bool</span>
<span class="sd">        :type   kwargs: dict&quot;&quot;&quot;</span>

        <span class="n">ig</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">IG</span><span class="p">)</span> <span class="k">if</span> <span class="n">IG</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_graph</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ig</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;The interaction graph has no nodes&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
            <span class="k">return</span>  <span class="c1"># Graph must have nodes to be drawn.</span>

        <span class="n">signs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="s1">&#39;sign&#39;</span><span class="p">)</span>
        <span class="n">sign_color</span> <span class="o">=</span> <span class="p">{</span><span class="n">edge</span><span class="p">:</span> <span class="n">SIGNCOLOR</span><span class="p">[</span><span class="n">signs</span><span class="p">[</span><span class="n">edge</span><span class="p">]]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">signs</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">modular</span><span class="p">:</span>  <span class="c1"># add module specification in edges.</span>
            <span class="n">modules</span> <span class="o">=</span> <span class="p">{</span><span class="n">edge</span><span class="p">:</span> <span class="n">module</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">module</span>
                       <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="s1">&#39;module&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">module_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">edge_labels</span><span class="o">=</span><span class="n">modules</span><span class="p">,</span>
                <span class="n">edge_label_position</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                <span class="n">edge_label_fontdict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;darkgray&#39;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">module_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">ng</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span>
                 <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;antiquewhite&#39;</span><span class="p">,</span>
                 <span class="n">node_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">node_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                 <span class="n">node_label_fontdict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">family</span><span class="o">=</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;semibold&#39;</span><span class="p">),</span>
                 <span class="n">arrows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">edge_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">edge_color</span><span class="o">=</span><span class="n">sign_color</span><span class="p">,</span>
                 <span class="n">pos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">module_args</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ig</span></div>


<div class="viewcode-block" id="BooN.from_ig">
<a class="viewcode-back" href="../index.html#boon.BooN.from_ig">[docs]</a>
    <span class="k">def</span> <span class="nf">from_ig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IG</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define the descriptor of a BooN from an interaction graph.</span>

<span class="sd">        :param  IG:  interaction graph.&quot;&quot;&quot;</span>
        <span class="c1"># Find the maximal number of modules for each targetvariable.</span>
        <span class="n">max_nb_modules</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">IG</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
        <span class="n">modules</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">IG</span><span class="p">,</span> <span class="s1">&#39;module&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
            <span class="n">max_nb_modules</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_nb_modules</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">modules</span><span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)])))</span>

        <span class="c1"># define the structure of the DNF as a list of sets where each set stands for a clause.</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_nb_modules</span><span class="p">[</span><span class="n">node</span><span class="p">])]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">IG</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
        <span class="c1"># Place the literal in clauses appropriately.</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">IG</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">IG</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;module&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">module</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">lit</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="k">elif</span> <span class="n">module</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">lit</span> <span class="o">=</span> <span class="n">Not</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lit</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;Null module is not admitted - possible origin : non-monotone network&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">module</span><span class="p">])</span>
                    <span class="n">nodes</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="nb">abs</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>

        <span class="c1"># convert into formula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">Or</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">clause</span><span class="p">)</span> <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span></div>


    <span class="c1"># DEF: DYNAMICS</span>
<div class="viewcode-block" id="BooN.model">
<a class="viewcode-back" href="../index.html#boon.BooN.model">[docs]</a>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">asynchronous</span><span class="p">,</span> <span class="n">self_loop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the dynamical datamodel of the BooN w.r.t. a mode.</span>

<span class="sd">        :param  self_loop: determines whether the boon loops are included in the datamodel (Default: False).</span>
<span class="sd">        :param  mode: determines the mode policy applied to the datamodel (Default: asynchronous).</span>
<span class="sd">        :type self_loop: bool</span>
<span class="sd">        :type mode: function</span>
<span class="sd">        :return: a Digraph representing the complete state based dynamics.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">next_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">change</span><span class="p">):</span>  <span class="c1"># update a state from changes.</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">target</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">change</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">target</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
        <span class="n">modalities</span> <span class="o">=</span> <span class="n">mode</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">allstates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">))]</span>
        <span class="c1"># Compute the state transition w.r.t. the network.</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">state</span><span class="p">,</span>
             <span class="n">next_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
                        <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">modality</span><span class="p">})</span>
             <span class="p">)</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">allstates</span> <span class="k">for</span> <span class="n">modality</span> <span class="ow">in</span> <span class="n">modalities</span><span class="p">]</span>
        <span class="c1"># remove duplicated transitions.</span>
        <span class="n">transition</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">transition</span><span class="p">)</span> <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transition</span><span class="p">[:</span><span class="n">i</span><span class="p">]]</span>
        <span class="c1"># remove boon loop if requested.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self_loop</span><span class="p">:</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">transition</span><span class="p">)</span>
        <span class="c1"># Graph creation with nodes as integers coding the states.</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="n">state2int</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">allstates</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">state2int</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">variables</span><span class="p">),</span> <span class="n">state2int</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">variables</span><span class="p">))</span> <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span> <span class="ow">in</span> <span class="n">transition</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="BooN.draw_model">
<a class="viewcode-back" href="../index.html#boon.BooN.draw_model">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">asynchronous</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">COLOR</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw the graph representing the datamodel of dynamics.</span>

<span class="sd">        :param  model: input datamodel graph of the BooN or None (Default: None). if it is None the asynchronous datamodel computed from the BooN.</span>
<span class="sd">        :param  mode: function characterizing the mode of the datamodel (Default: asynchronous)</span>
<span class="sd">        :param  color: list of colors for highlighting the equlibria (Default: COLOR)</span>
<span class="sd">        :param  kwargs: extra parameters of nx.draw_networkx.</span>
<span class="sd">        :type model: networkx DiGraph</span>
<span class="sd">        :type mode: function</span>
<span class="sd">        :type color: list</span>
<span class="sd">        :type kwargs: dict&quot;&quot;&quot;</span>

        <span class="n">themodel</span> <span class="o">=</span> <span class="n">model</span> <span class="k">if</span> <span class="n">model</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">eqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equilibria</span><span class="p">(</span><span class="n">themodel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the number of colors is insufficient to highlight the equilibria, length of color: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span><span class="si">}</span><span class="s2">, number of attractors&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">eqs</span><span class="p">))</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>

        <span class="k">def</span> <span class="nf">colorize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>  <span class="c1"># Return the color associated to the attractor in which the node is located otherwise -1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eqs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">int2state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="s1">&#39;oldlace&#39;</span>

        <span class="k">def</span> <span class="nf">is_eq</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eqs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">int2state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">themodel</span><span class="p">,</span>
                         <span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="nb">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">themodel</span><span class="o">.</span><span class="n">nodes</span><span class="p">()},</span>
                         <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">font_size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
                         <span class="n">font_family</span><span class="o">=</span><span class="s1">&#39;fantasy&#39;</span><span class="p">,</span>
                         <span class="n">node_shape</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
                         <span class="n">node_size</span><span class="o">=</span><span class="p">[</span><span class="mi">200</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">themodel</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_eq</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">else</span> <span class="mi">200</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">themodel</span><span class="o">.</span><span class="n">nodes</span><span class="p">()],</span>
                         <span class="n">node_color</span><span class="o">=</span><span class="p">[</span><span class="n">colorize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">themodel</span><span class="o">.</span><span class="n">nodes</span><span class="p">()],</span>
                         <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;oldlace&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round,pad=0.1&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span>
                         <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                         <span class="n">arrowsize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                         <span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-|&gt;&#39;</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span>
                         <span class="p">)</span></div>


<div class="viewcode-block" id="BooN.equilibria">
<a class="viewcode-back" href="../index.html#boon.BooN.equilibria">[docs]</a>
    <span class="k">def</span> <span class="nf">equilibria</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">asynchronous</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate equilibria for the network based on datamodel dynamics. The method examines an exponential number of states, and thus it is restricted to networks with a small number of variable (max. ~10).</span>

<span class="sd">        :param  model: data model from which the  equilibria are calculated. If the datamodel is None, then the datamodel will be calculated from BooN. (Default: None)</span>
<span class="sd">        :param  mode: updating mode function, used if the datamodel is None  (Default: asynchronous).</span>
<span class="sd">        :type model: networkx DiGraph</span>
<span class="sd">        :type mode: function</span>
<span class="sd">        :return: Equilibria structure as a list of lists where each sublist is an attractor.</span>
<span class="sd">        :rtype: list[list]&quot;&quot;&quot;</span>

        <span class="n">themodel</span> <span class="o">=</span> <span class="n">model</span> <span class="k">if</span> <span class="n">model</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="n">scc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">(</span><span class="n">themodel</span><span class="p">))</span>  <span class="c1"># Compute the Strongly Connected Components.</span>
        <span class="n">quotient_model</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">quotient_graph</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">scc</span><span class="p">)</span>  <span class="c1"># Deduce the quotient graph of the SCCs.</span>
        <span class="n">equilibria</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">quotient_model</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">quotient_model</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Determine equilibria as the sink in the quotient graph, i.e. terminal SCC.</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">int2state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">attractor</span><span class="p">]</span> <span class="k">for</span> <span class="n">attractor</span> <span class="ow">in</span> <span class="n">equilibria</span><span class="p">]</span>  <span class="c1"># Encode the equilibria.</span></div>


<div class="viewcode-block" id="BooN.stability_constraints">
<a class="viewcode-back" href="../index.html#boon.BooN.stability_constraints">[docs]</a>
    <span class="k">def</span> <span class="nf">stability_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define the stability constraints for a BooN.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">var</span><span class="p">:</span> <span class="n">Equivalent</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stable_states</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute all the stable states of a BooN. The algorithm is based on SAT solver.</span>

<span class="sd">        :return: list of stable states.</span>
<span class="sd">        :rtype: list[dict]&quot;&quot;&quot;</span>

        <span class="n">solver</span> <span class="o">=</span> <span class="n">z3</span><span class="o">.</span><span class="n">Solver</span><span class="p">()</span>  <span class="c1"># initialize z3 solver</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">logic</span><span class="o">.</span><span class="n">sympy2z3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stability_constraints</span><span class="p">()))</span>  <span class="c1"># add stability constraints translated in z3.</span>

        <span class="c1"># Enumerate all models</span>
        <span class="n">models</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">z3</span><span class="o">.</span><span class="n">sat</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
            <span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="c1"># Block the current datamodel to enable the finding of another datamodel.</span>
            <span class="n">block</span> <span class="o">=</span> <span class="p">[</span><span class="n">sol</span><span class="p">()</span> <span class="o">!=</span> <span class="n">model</span><span class="p">[</span><span class="n">sol</span><span class="p">]</span> <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">model</span><span class="p">]</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Or</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

        <span class="c1"># convert the solution to a list of states.</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="p">{</span><span class="n">symbols</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">())):</span> <span class="nb">bool</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="n">sol</span><span class="p">])</span> <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">model</span><span class="p">},</span> <span class="n">models</span><span class="p">))</span>

    <span class="c1"># DEF CONTROLLABILITY</span>

<div class="viewcode-block" id="BooN.control">
<a class="viewcode-back" href="../index.html#boon.BooN.control">[docs]</a>
    <span class="k">def</span> <span class="nf">control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frozenfalse</span><span class="p">:</span> <span class="nb">set</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">,</span> <span class="n">frozentrue</span><span class="p">:</span> <span class="nb">set</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set control on the BooN. The  controlled variables are divided in two classes:</span>
<span class="sd">        the variables frozen to false and the variables frozen to true. A variable can be in both classes.</span>

<span class="sd">        :param frozenfalse: list, set or sequence of variables that should be frozen to false by control.</span>
<span class="sd">        :param frozentrue: list, set or sequence  of variables that should be frozen to true by control.</span>
<span class="sd">        :type frozenfalse: iterable object (list, set, tuple)</span>
<span class="sd">        :type frozentrue: iterable object (list, set, tuple)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">frozenfalse</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">u0</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">CONTROL</span><span class="si">}</span><span class="s2">0</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">u0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;The variable is not found, skipped&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">frozentrue</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">CONTROL</span><span class="si">}</span><span class="s2">1</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">Not</span><span class="p">(</span><span class="n">u1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;The variable is not found, skipped&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="s2">&quot;WARNING&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooN.possibly">
<a class="viewcode-back" href="../index.html#boon.BooN.possibly">[docs]</a>
    <span class="k">def</span> <span class="nf">possibly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the possibility constraint.</span>

<span class="sd">        :param query: a formula characterizing the query, objective or goal.</span>
<span class="sd">        :type query: sympy formula</span>
<span class="sd">        :return: a formula specifying the possibility.</span>
<span class="sd">        :rtype: sympy formula&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stability_constraints</span><span class="p">(),</span> <span class="n">query</span><span class="p">)</span></div>


<div class="viewcode-block" id="BooN.necessary">
<a class="viewcode-back" href="../index.html#boon.BooN.necessary">[docs]</a>
    <span class="k">def</span> <span class="nf">necessary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the necessary constraints.</span>

<span class="sd">        :param query: a formula characterizing the query, objective or goal.</span>
<span class="sd">        :param trace: Boolean flag determining whether the trace is activated (Default value = False).</span>
<span class="sd">        :type query: sympy formula</span>
<span class="sd">        :type trace: bool</span>
<span class="sd">        :return: CNF specifying the necessity.</span>
<span class="sd">        :rtype: sympy formula&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Specification of the necessity.</span>
        <span class="n">stability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_constraints</span><span class="p">()</span>  <span class="c1"># stable stables specification</span>
        <span class="n">necessity</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">supercnf</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">stability</span><span class="p">,</span> <span class="n">query</span><span class="p">),</span> <span class="n">trace</span><span class="p">)</span>  <span class="c1"># Necessary conversion into CNF of the query.</span>
        <span class="n">necessary</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">clause</span><span class="p">:</span>
                             <span class="n">Or</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">lit</span> <span class="k">for</span> <span class="n">lit</span> <span class="ow">in</span> <span class="n">logic</span><span class="o">.</span><span class="n">clause2literals</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span> <span class="k">if</span> <span class="n">firstsymbol</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">CONTROL</span><span class="p">)]),</span>
                             <span class="n">logic</span><span class="o">.</span><span class="n">cnf2clauses</span><span class="p">(</span><span class="n">necessity</span><span class="p">)))</span>  <span class="c1"># Keep the control variables only.</span>
        <span class="k">return</span> <span class="n">necessary</span></div>


<div class="viewcode-block" id="BooN.destify">
<a class="viewcode-back" href="../index.html#boon.BooN.destify">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">destify</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">PULP_CBC_CMD</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the core which is the minimal set of controls under the inclusion to satisfy the query at stable state.</span>
<span class="sd">        Destify is a neologism that refers to the deliberate and purposeful act for shaping destiny by</span>
<span class="sd">        influencing or directing the course of events or outcomes towards an expected goal.</span>

<span class="sd">        :param query: the query defining the expected destiny or goal as propositional formula.</span>
<span class="sd">        :param trace: Boolean flag determining whether the trace is activated (Default: False).</span>
<span class="sd">        :param solver: the PulpSolver used for solving the problem (Default: PULP_CBC_CMD).</span>
<span class="sd">        :type query: sympy formula</span>
<span class="sd">        :type trace: bool</span>
<span class="sd">        :type solver: type</span>
<span class="sd">        :return: the core of control</span>
<span class="sd">        :rtype: frozenset[sympy formula]&quot;&quot;&quot;</span>

        <span class="c1"># predicate determining whether a literal is a negative control (e.g. ~ _u1).</span>
        <span class="k">def</span> <span class="nf">isnegctrl</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">firstsymbol</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">CONTROL</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lit</span><span class="p">,</span> <span class="n">Not</span><span class="p">)</span>

        <span class="c1"># Check if the query contains control variables.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_controlled</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
            <span class="n">errmsg</span><span class="p">(</span><span class="s2">&quot;The query has no controls of prefix&quot;</span><span class="p">,</span> <span class="n">CONTROL</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;WARNING&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>

        <span class="n">allprimes</span> <span class="o">=</span> <span class="n">logic</span><span class="o">.</span><span class="n">prime_implicants</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">isnegctrl</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">)</span>
        <span class="c1"># The result is of the form ~ _u0X or ~_u1X. we need to get the control variable i.e. _u0X, _u1X</span>
        <span class="n">ctrlprimes</span> <span class="o">=</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">firstsymbol</span><span class="p">(</span><span class="n">prime</span><span class="p">)</span> <span class="k">for</span> <span class="n">prime</span> <span class="ow">in</span> <span class="n">primes</span><span class="p">})</span> <span class="k">for</span> <span class="n">primes</span> <span class="ow">in</span> <span class="n">allprimes</span><span class="p">}</span>

        <span class="c1"># Define the core composed of prime implicant sets that are minimal under the inclusion.</span>
        <span class="n">core</span> <span class="o">=</span> <span class="p">{</span><span class="n">primeset</span> <span class="k">for</span> <span class="n">primeset</span> <span class="ow">in</span> <span class="n">ctrlprimes</span> <span class="k">if</span>
                <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">otherprimeset</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="n">otherprimeset</span> <span class="o">&lt;</span> <span class="n">primeset</span><span class="p">),</span> <span class="n">allprimes</span><span class="p">))}</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">core</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Franck Delaplace.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>